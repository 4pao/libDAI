/*  This file is part of libDAI - http://www.libdai.org/
 *
 *  libDAI is licensed under the terms of the GNU General Public License version
 *  2, or (at your option) any later version. libDAI is distributed without any
 *  warranty. See the file COPYING for more details.
 *
 *  Copyright (C) 2008-2010  Joris Mooij  [joris dot mooij at libdai dot org]
 */


#include <iostream>
#include <fstream>
#include <dai/alldai.h>
#include <dai/util.h>
#include <dai/index.h>
#include <dai/jtree.h>


using namespace std;
using namespace dai;


map<size_t, size_t> ReadUAIEvidenceFile( char *filename ) {
    map<size_t, size_t> evid;

    ifstream is;
    is.open( filename );
    if( is.is_open() ) {
        size_t nr_evid;
        is >> nr_evid;
        if( is.fail() )
            DAI_THROWE(INVALID_EVIDENCE_FILE,"Cannot read number of observed variables");

        for( size_t i = 0; i < nr_evid; i++ ) {
            size_t label, val;
            is >> label;
            is >> val;
            evid[label] = val;
        }

        is.close();
    } else
        DAI_THROWE(CANNOT_READ_FILE,"Cannot read from file " + std::string(filename));

    return evid;
}


pair<vector<Var>, vector<Factor> > ReadUAIFGFile( const char *filename, long verbose ) {
    vector<Factor> factors;
    vector<Var> vars;

    ifstream is;
    is.open( filename );
    if( is.is_open() ) {
        try { // FIXME: no exceptions are generated by iostreams by default
            size_t nr_f, nr_v;
            string line;
            
            getline(is,line);
            if( line != "BAYES" && line != "MARKOV" && line != "BAYES\r" && line != "MARKOV\r" )
                DAI_THROW(INVALID_FACTORGRAPH_FILE);
            if( verbose >= 2 )
                cout << "Reading " << line << " network..." << endl;

            is >> nr_v;
            if( is.fail() )
                DAI_THROW(INVALID_FACTORGRAPH_FILE);
            if( verbose >= 2 )
                cout << "Reading " << nr_v << " variables..." << endl;

            for( size_t i = 0; i < nr_v; i++ ) {
                size_t dim;
                is >> dim;
                if( is.fail() )
                    DAI_THROW(INVALID_FACTORGRAPH_FILE);
                vars.push_back( Var( i, dim ) );
            }

            is >> nr_f;
            if( is.fail() )
                DAI_THROW(INVALID_FACTORGRAPH_FILE);
            if( verbose >= 2 )
                cout << "Reading " << nr_f << " factors..." << endl;

            vector<vector<long> > labels;
            for( size_t I = 0; I < nr_f; I++ ) {
                if( verbose >= 3 )
                    cout << "Reading factor " << I << "..." << endl;
                size_t I_nrvars;
                is >> I_nrvars;
                if( verbose >= 3 )
                    cout << "  I_nrvars: " << I_nrvars << endl;

                vector<long> I_labels;
                vector<size_t> I_dims;
                VarSet I_vars;
                for( size_t _i = 0; _i < I_nrvars; _i++ ) {
                    long label;
                    is >> label;
                    I_labels.push_back(label);
                    I_dims.push_back(vars[label].states());
                    I_vars |= vars[label];
                }
                if( verbose >= 3 )
                    cout << "  labels: " << I_labels << ", dimensions " << I_dims << endl;

                // add the Factor and the labels
                factors.push_back(Factor(I_vars,0.0));
                labels.push_back(I_labels);
                
            }

            for( size_t I = 0; I < nr_f; I++ ) {
                if( verbose >= 3 )
                    cout << "Reading factor " << I << "..." << endl;

                reverse(labels[I].begin(), labels[I].end());    // last label is least significant

                size_t I_nrvars = factors[I].vars().size();
                vector<size_t> I_dims;
                for( size_t _i = 0; _i < I_nrvars; _i++ )
                    I_dims.push_back(vars[labels[I][_i]].states());
                if( verbose >= 3 )
                    cout << "  labels: " << labels[I] << ", dimensions " << I_dims << endl;

                // calculate permutation sigma (internally, members are sorted)
                vector<size_t> sigma(I_nrvars,0);
                VarSet::const_iterator j = factors[I].vars().begin();
                for( size_t mi = 0; mi < I_nrvars; mi++,j++ ) {
                    long search_for = j->label();
                    vector<long>::iterator j_loc = find(labels[I].begin(),labels[I].end(),search_for);
                    sigma[mi] = j_loc - labels[I].begin();
                }
                if( verbose >= 3 )
                    cout << "  sigma: " << sigma << endl;

                // calculate multindices
                Permute permindex( I_dims, sigma );
                
                // read values
                size_t nr_nonzeros;
                is >> nr_nonzeros;
                if( verbose >= 3 ) 
                    cout << "  nonzeroes: " << nr_nonzeros << endl;
                assert( nr_nonzeros == factors[I].states() );
                for( size_t li = 0; li < nr_nonzeros; li++ ) {
                    double val;
                    is >> val;
                    factors[I][permindex.convertLinearIndex( li )] = val;
                }
            }

            if( verbose >= 3 )
                cout << "factors:" << factors << endl;


            is.close();
        } catch (...) {
            is.close();
            throw;
        }
    } else
        DAI_THROW(CANNOT_READ_FILE);

    return pair<vector<Var>, vector<Factor> >(vars,factors);
}


int main( int argc, char *argv[] ) {
    if ( argc != 6 ) {
        cout << "Usage: " << argv[0] << " <filename.uai> <filename.uai.evid> <filename.fg> <type> <run_jtree>" << endl << endl;
        cout << "Converts input files from UAI approximate inference evaluation to" << endl;
        cout << "libDAI factor graph format." << endl;
        cout << "Reads factor graph <filename.uai> and evidence <filename.uai.evid>" << endl;
        cout << "and writes the clamped factor graph to <filename.fg>." << endl;
        cout << "If type==0, uses surgery, otherwise, uses safe method." << endl;
        cout << "If run_jtree!=0, runs a junction tree and reports the results in the UAI 2008 results file format." << endl;
        return 1;
    } else {
        long verbose = 0;
        long type = atoi( argv[4] );
        bool run_jtree = atoi( argv[5] );

        pair<vector<Var>, vector<Factor> > input;
        input = ReadUAIFGFile( argv[1], verbose );
        FactorGraph fg0( input.second );
        map<size_t,size_t> evid = ReadUAIEvidenceFile( argv[2] );
        double logZcorr = 0.0;
        if( type == 0 ) {
            for( size_t I = 0; I < input.second.size(); I++ ) {
                for( map<size_t,size_t>::const_iterator e = evid.begin(); e != evid.end(); e++ ) {
                    if( input.second[I].vars() >> input.first[e->first] ) {
                        if( verbose >= 2 )
                            cout << "clamping " << e->first << " to value " << e->second << " in factor " << I << " = " << input.second[I].vars() << endl;
                        input.second[I] = input.second[I].slice( input.first[e->first], e->second );
                        if( verbose >= 2 )
                            cout << "...remaining vars: " << input.second[I].vars() << endl;
                    }
                }
            }
            // remove empty factors
            for( vector<Factor>::iterator I = input.second.begin(); I != input.second.end(); )
                if( I->vars().size() == 0 ) {
                    logZcorr += std::log( (Real)(*I)[0] );
                    I = input.second.erase( I );
                } else
                    I++;
            // multiply with logZcorr constant
            if( input.second.size() == 0 )
                input.second.push_back( Factor( VarSet(), std::exp(logZcorr) ) );
            else
                input.second.front() *= std::exp(logZcorr);
        }
        for( map<size_t,size_t>::const_iterator e = evid.begin(); e != evid.end(); e++ ) {
            // add delta factors
            input.second.push_back( Factor( input.first[e->first], 0.0 ) );
            input.second.back()[e->second] = 1.0;
        }
        FactorGraph fg(input.second);

        fg.WriteToFile( argv[3] );

        if( run_jtree ) {
            JTree jt0( fg0, PropertySet()("updates",string("HUGIN")) );
            jt0.init();
            jt0.run();

            JTree jt( fg, PropertySet()("updates",string("HUGIN")) );
            jt.init();
            jt.run();

            cout.precision( 8 );
            if( evid.size() )
                cout << "z " << (jt.logZ() - jt0.logZ()) / dai::log((Real)10.0) << endl;
            else
                cout << "z " << jt.logZ() / dai::log((Real)10.0) << endl;

            cout << "m " << jt.nrVars() << " ";
            for( size_t i = 0; i < jt.nrVars(); i++ ) {
                cout << jt.var(i).states() << " ";
                for( size_t s = 0; s < jt.var(i).states(); s++ )
                    cout << jt.beliefV(i)[s] << " ";
            }
            cout << endl;

            cout << "s ";
            jt.props.inference = JTree::Properties::InfType::MAXPROD;
            jt.init();
            jt.run();
            vector<size_t> MAP = jt.findMaximum();
            map<Var, size_t> state;
            for( size_t i = 0; i < MAP.size(); i++ )
                state[jt.var(i)] = MAP[i];
            double log_MAP_prob = 0.0;
            for( size_t I = 0; I < jt.nrFactors(); I++ )
                log_MAP_prob += dai::log( jt.factor(I)[calcLinearState( jt.factor(I).vars(), state )] );
            if( evid.size() )
                cout << (log_MAP_prob - jt0.logZ()) / dai::log((Real)10.0) << " ";
            else
                cout << log_MAP_prob / dai::log((Real)10.0) << " ";

            cout << jt.nrVars() << " ";
            for( size_t i = 0; i < jt.nrVars(); i++ )
                cout << MAP[i] << " ";
            cout << endl;
        }
    }

    return 0;
}
